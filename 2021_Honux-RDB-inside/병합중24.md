# 0524 호눅스DB

### MySQL에서 CREATE TABLE을 했다면 벌어지는 것은?

![./img_0524/Untitled.png](./img_0524/Untitled.png)

- MySQL의 스토리지엔진은?
    - InnoDB
            - `row store`
            - 레코드가 모여서 저장한다는 것은 테이블이 생성될 때 a,b 레코드가 붙어서 저장됨
                - `column store` : filed를 묵어서 저장
            - 스토리지에서 레코드의 모음집을 뭐라고 말할까?
                - Pages
                - InnoDB에서는 레코드를 묶어서 페이지를 구성한다.

                ![./img_0524/Untitled%201.png](./img_0524/Untitled%201.png)

            - 그럼 cloumn store는?

                ![./img_0524/Untitled%202.png](./img_0524/Untitled%202.png)

                - 주로, 빅데이터에서 사용한다.
                - 필드검색 `SELECT A` 만할 때 row store 보다 유리하다.

                ![./img_0524/Untitled%203.png](./img_0524/Untitled%203.png)

                - 어떤차이?
                - 컬럼 스토어는 A가 있는 페이지만 뒤지면 되니 50%밖에 발생하지 않음

                ## 로우 스토어 VS 컬럼 스토어

                ![./img_0524/Untitled%204.png](./img_0524/Untitled%204.png)

                - 컬럼스토어는 분석쿼리에 유리
                - 필드를 조회하고, 통계 평균 낼때
                - 분석 쿼리 전문 : `RedShift`
                    - 같은거 MYSQL에 돌리면 2박3일이 걸리지면 RedShift에 돌리면 30분정도 거린다함.

                관계형데이터베이스는 주로 row sotre로 돼있음.

                - 페이지는 물리적인 단위이기 때문에, 필드를 모은 것도 `page`임

                ```java
                K (백엔드)님이 모두에게:  02:32 PM
                일반적으로 DB 페이지 단위가 OS 페이지 크기랑 같나요?

                ----------------

                DB 페이지가 OS페이지보다 큰경우가많음

                OS는 블록이라함

                운영체제는 페이지를 사용하지 않음 운영체제의 페이지는 메모리 억세스
                디스크의 페이지는 블록이라고 부름
                운영체제에서 결정하는 것이 아닌 기계적으로 결정이됨.

                DB는 페이지로 관리하는데 블록의 N배수 이다.
                ```

                ```java
                아이작(백엔드)님이 모두에게:  02:35 PM
                mysql이랑 이노 db랑 관계가 인터페이스랑 구현체 느낌으로 받아들이면 된요?

                MySQL에서 스토리지 엔진에 대한 인터페이스를 제공해주고,
                그것을 구현해준게 InnoDB이다.

                요즘 표준은 InnoDB이지만 그외에도 엄청 많음

                List of storage engines

                InnoDB.
                MyISAM.  <- MySQL 3.XX 기본으로 들어있던 엔진 (예전 표준)
                Memory. <- MySQL에서 메모리 엔진을 쓰고싶을 때 사용
                CSV. <- Comma Seprated Value, 데이터를 CSV로 저장하는 엔진
                Merge.
                Archive.
                Federated.
                Blackhole.

                ```

                이노디비에서 `T (a int pk, b char(50))` 테이브을 만들면 무슨일이 벌어지나?

                - PK를 가지고 `인덱스`를 만듬.
                    - 인덱스는 `B+ Tree` 로 구성된다.
                        - `B+Tree`

                            ![./img_0524/Untitled%205.png](./img_0524/Untitled%205.png)

                        - 자체는 트리의 형태이고, `leaf 노드에 실제 데이터가 매달린다.`
                        - non-leaf 노드에서는 다음 페이지에대한 참조를 가지고 있음.
                            - 범위 검색을 지원하기 위해서 가지고 있는 것임.
                            - 없어도 안되는 건 아니지만, 루트에서 아래로 가야해서 오래걸림

                    ### 요약하면 B+ TREE는 B TREE 와 다른 것

                    - 일반적으로 사람들이 DB는 B TREE를 사용한다고 하지만 그것은 B+ TREE
                    - B - TREE
                        - `B 마이너스 트리가 아니라 B 트리임.`
                    - B + TREE

                    ### B TREE VS B+TREE

                    - [https://python-wiki.appspot.com/?p=5846034605408256](https://python-wiki.appspot.com/?p=5846034605408256)
                    - [https://ssup2.github.io/theory_analysis/B_Tree_B+_Tree/](https://ssup2.github.io/theory_analysis/B_Tree_B+_Tree/)

                    ![./img_0524/Untitled%206.png](./img_0524/Untitled%206.png)

                    - `이그림은 전부 인덱스 페이지`
                    - 디스크의 페이지 번호, 분홍색은 디스크 포인터
                    - `데이터 페이지는 분홍색을 따라가면 데이터페이지`
                    - B+TREE는 LEAF NODE에만 데이터를 가지고 있음.
                    - B-TREE는 모든 NODE에 데이터를 가지고 있음.
                    - `노드 하나하나가 페이지임.`
                        - 왜 페이지 단위로 할까? ( 4KB)
                            - 페이지라는 것은 대체 뭘까?
                            - I/O의 단위도 페이지
                            - 레코드 단위로 읽으면 너무 비효율적
                            - `디스크를 읽을 때 한번에 페이지 단위로 읽는다.`
                                - 어째서 바이트, 레코드 단위로 읽지 않는 걸까?
                                    - 바이트로 읽는다는것은 한번에
                                - `I/O가 빈번하면 느려짐`
                                - 하드디스크는 물리적으로 동그랗게 생김

                                    ![./img_0524/Untitled%207.png](./img_0524/Untitled%207.png)

                                    - 안쪽을 읽으려면 헤더가 안쪽으로 이동해야함
                                    - 비효율적이지만 내부 블록이랑 용량이 같음
                                    - 문제는 물리적으로 읽는데 한계가 있어서 내부 읽을 수록 시간이 오래걸림
                                        - 하드디스크는 랜덤으로 읽는게 어려움
                                    - 1바이트 읽는거랑 10바이트 읽는거랑 512바이트 읽는거랑 4096바이트 읽는거랑 속도차이
                                        - 하나 씩 읽는건 다 같고
                                        - 100MB 읽기 대회를 한다면?
                                            - 당연히 4KB씩 읽는게 이김
                                    - LBA ( Logical Block Access)
                                    - 요새는 ssd
                                        - 하드디스크를 에뮬리이션 한것
                                        - 실린더 섹터를 가지고 제어를함
                                        - 
                    - B-TREE
                        - Primary 10을 가지는 데이터는 바로 갈 수 있음
                    - B+TREE
                        - Primary 6을 찾을때 6→ 5→6 이런식으로 걸림
                        - `리프노드에는 항상 모든 값을 다 가지고 있음`
                            - 데이터는 항상 리프노드에 대한 포인터가 있으니까
                        - 범위 검색에 유리

                    - B-TREE와 B+TREE는 모두 `디스크`에 저장이됨.
                        - 그럼 DB에서 디스크의 저장단위는 `페이지`
                            - 페이지: 하나 이상의 물리적인 블록의 집합
                            - 페이지는 가장 작은 것이 `4096바이트`
                                - INT 4바이트니 대충 1000개 저장할 수 있음.

                    - 인덱스는 인덱스 페이지, 데이터는 데이터 페이지

                    ```java
                    B-Tree 는 Index Page 랑 Data Page 가 같은 Page 이고, 
                    B+Tree 는 분리되어 있다라고 이해하면 되나요?

                    전부 아니다. 

                    둘다 똑같이 인덱스는 인덱스밖에 없고

                    인덱스와 데이터페이지는 따로임

                    데이터페이지는 레코드가 들어있음
                    - 총 4가지 방식이 있음.
                    - 데이터는 PK 기준으로 정렬이 돼있음.
                      - 레코드들은 데이터페이지에 정렬돼서 들어가있음

                    인덱스 종류가 많지만 기본적으로 b+ TREE

                    B TREE는 특정 노드의 링크가 있다. 인덱스페이지에서 각 노드로 바로 갈 수 있다.

                    B+ TREE는 데이터포인트가 없어서 리프노드로 가야함

                    ```

                ![./img_0524/Untitled%208.png](./img_0524/Untitled%208.png)

                ## B+ TREE

                ```java
                Pyro(고정완)님이 모두에게:  02:59 PM
                Tree 의 동그라미 한개는 Page 한개의 이야기로 돌아가야겠군요.

                왜 동그라미가 Page 단위이죠?

                페이지가 IO의 단위다 보니까, 통쨰로 읽고 쓸때 가장 효율적으로 읽고 쓰기가 되기 때문에 노드 하나의 단위를 페이지와 맞춰준 것이다.

                동그라미 하나가 페이지라는게, 등그라미 하나가 페이지 주소를 갖는다는 것
                ```

                - 노드 하난대 값을 여러개 가지고 있음
                - order 라는게 최대 4개까지 데이터를 가질 수 있다는 것
                - `일반적인 b tree는 order 가 1024쯤됨.`
                - b tree를 디스크에 쓸 때
                - 레코드 백 만개 저장하면 b tree의 높이는?
                    - `3~4`
                    - b tree 5단계 되는 경우는 안생김
                        - 레코드가 1000^5 , 약 1000조개 들어가야 5단계가 됨.
                        - 아직 이런 db는 없음

            ![./img_0524/Untitled%209.png](./img_0524/Untitled%209.png)

            - 테이블을 만들면 프라이머리 키를 가지고 자동으로 B+ TREE 인덱스가 만들어집니다.
            - 데이터페이지는 PK 기준으로 정렬이 돼있다.
            - 이것을 통쨰로 `클러스터링 인덱스` 자료구조라고 한다.

            ```java
            Row store의 경우 a를 검색할때 왜 전체를 살펴야 하는 걸까요...
            ```

            ![./img_0524/Untitled%2010.png](./img_0524/Untitled%2010.png)

            ![./img_0524/Untitled%2011.png](./img_0524/Untitled%2011.png)

            [http://www.hanaexam.com/p/row-store-vs-column-store.html](http://www.hanaexam.com/p/row-store-vs-column-store.html)

            - 모든 레코드 단위로 저장돼다보니 모든 페이지에 있음
            - 읽기의 단위가 페이지다 보니 생기는 문제임.
            - 그래서 다 읽어야함.
            - COVERING INDEX

        반면에 컬럼 스토리지는

        - 필드로 저장되니 바로 탐색 가능

        ```java
        로우 스토어에서 레코드 단위로 모든 페이지에 저장되는 부분 다시 설명해주실 수 있나요 ㅠㅠ
        ```

        5개의 레코드가 있을 때

        ![./img_0524/Untitled%2012.png](./img_0524/Untitled%2012.png)

        ROW STORE

        ![./img_0524/Untitled%2013.png](./img_0524/Untitled%2013.png)

        COLUMN STORE

        ![./img_0524/Untitled%2014.png](./img_0524/Untitled%2014.png)

        [Moer and Éric Moreau's web site](https://www.emoreau.com/PrintThisPage.aspx?ID=568)

        ## 

        ![./img_0524/Untitled%2015.png](./img_0524/Untitled%2015.png)

        외래키는 제약조건

        - 참조하는 부모테이블의 특정 pk 필드를 참조하는 외래키는 그 값이 a값중 하나의 값이거나 null이어야한다.
            - 즉, a에 넣을때마다 a[1,2,3] 이라면 a`[1,2,3,null ] 까지 4개가 올 수 있음
            - 레코드를 넣을때마다 레코드 검사를 함
            - t2에  4를 넣으면 안들어가짐
                - 그럼 DB(InnoDB)가 검사를 어떻게 할까?
                    - 이값들이 모두 메모리가 아닌 디스크에 있다고 가정해야함.
                    - 일반적으로 데이터베이스 크기가 엄청 크기 때문임.
                    - 메모리에 모두 못올라간다.
                    - 디스크를 항상 뒤질 수 밖에 없음.
                    - 하지만 크게 문제되지 않는 이유는 a에 대해서 인덱스가 있기떄문이다.
                    - 페이지를 최대 3개만 뒤지면 된다.
        - 물리적으로는 인덱스가 생성됨.

        - 클러스터링 인덱스에서 가장 많이 접근하는 페이지는 root
            - 자주 사용하기 때문에 100% 메모리에 넣어서 캐싱을 사용함
        - 외래키가 있다는 것은 테이블을 조인을 할 수 밖에없음.
            - 조인을 어떻게해? t1 테이블에 레코드들이 모두 a값으로 정렬이 돼있음
            - t2의 경우 d로 정렬이 돼있음.

                ![./img_0524/Untitled%2016.png](./img_0524/Untitled%2016.png)

            - 조인이라 함은 어떻게 하면 효과적?
                - 외래키에 인덱스

            ## DB 물리적 구조

            - 프라이머리 인덱스

            ![./img_0524/Untitled%2017.png](./img_0524/Untitled%2017.png)

        - d에 a`들이 조금씩 섞여있음.
            - a`를 가지고 인덱스를 만듬.

            - secondary index

                ![./img_0524/Untitled%2018.png](./img_0524/Untitled%2018.png)

                - 얘도 b+tree인데
                - 리프노드에서 가리키는 곳은 어디일까?
                    - 2가지가 있음.
                    - 직접 데이터를 가리킬 수 있음, 인덱스 페이지의 프라이머리 인덱스를 가리킬 수 있음.
                    - 하지만 RDBMS는 A방식을 사용함 ( 프라이머리 인덱스 가리키는 )
                        - 데이터인덱스를 찾아가는 간접구조로 돼어있음

                    ![./img_0524/Untitled%2019.png](./img_0524/Untitled%2019.png)

                    - 외래키를 생성하면 인덱스가 하나 자동으로 만들어짐.
                        - 그 인덱스는 프라이머리키랑 구조가 `다르다.`
                            - 프라이머리 키는 리프에서 데이터페이지를 가리키는 반면
                            - 포린키 인덱스는 PK의 인덱스 페이지를 가리킨다.

                    - `유니크 인덱스`

                        ![./img_0524/Untitled%2020.png](./img_0524/Untitled%2020.png)

                        - A int UNIQUE
                            - 중복을 허용하지 않는다.
                            - 어떻게할까? 생각
                                - 정렬
                                - 데이터를 해시 자료구조로 저장
                                - 해시를 만든다는것은 별도의 인덱스를 만드는 것이라 잘 안씀
                                - 전부뒤지기
                                - 유니크 인덱스

                        - 커스텀 인덱스
                            - 검색을 빠르게 하기 위해서
                            - `삽입, 삭제가 느려짐`
                            - CREATE INDEX ISAC1 ON T1(C)

                                ![./img_0524/Untitled%2021.png](./img_0524/Untitled%2021.png)

                                - 인덱스라는 것은 값이 들어가면 인덱스 조직을 다 `재구조`화 해줘야하기때문에 느려진다.

                                PK 의 인덱스

                                - 리프노드가 데이터를 참조하고, RDBMS의 데이터베이스는 PK순으로 정렬돼있다.
                                - Clustering Index
                                    - Clustering Index = `PK Index Page + PK Sorting Data Page`

                                  세컨더리 인덱스

                            - 리프노드가 PK 를 참조한다.
                                - 포린키 인덱스
                                - 유니크 인덱스
                                - 리프노드가

                            ### 복합 인덱스

                            ![./img_0524/Untitled%2022.png](./img_0524/Untitled%2022.png)

                            - WHERE 절에 두 개를 동시에 검색할 때
                            - b랑 d를 and 조건으로 찾아야할 때

                            ## SELECT * 를 쓰면 안됨.

                            - 어느게 더 빠를까?
                                - #A 가 훨씬 더빠름
                                    - b,c 필드가 인덱스에 있어서 데이터까지 안가도됨.
                                    - 인덱스를 가면, 데이터에 접근 안해도됨.
                                    - 오징어 머리만 읽으면 됨
                                    - `Covering Index` 💥💥💥
                                        - 인덱스만 읽어도 쿼리가 다 수행될 수 있는 경우에 인덱스가 모든 걸 커버했다.
                                    - 데이터 페이지를 안읽어서 성능이 매우 좋음
                                        - 하지만 인덱스를 마구 만든다고 항상 좋은게 아님
                                - #B
                                    - 모든 필드를 다가지고옴

                            ```sql
                            T1(a,b,c,d)

                            a : PK

                            b: Index 1

                            (b,c) : Composed Index 2 : 복합인덱스

                            -----

                            #A, 인덱스에 가서 데이터에 접근 안해도됨. 
                            # 인덱스에 B,C가 다 들어있음.
                            # 머리만 가져오면 됨.

                            SELECT A, B, FROM T1

                            WHERE A > 50 AND B < 20;

                            ---------------------

                            #B
                            # 모든 필드를 다가져와서, A를 읽기전에 뭔가 다른 필드를 탐색하는 과정이 있음.

                            SELECT * FROM T1

                            WHERE C > 50 AND B < 20;
                            ```

                            ```sql
                            b랑 c랑 각각 인덱스 걸려있어도 커버링 인덱스 조건이 되죠?

                            - 그렇지 않음, 복합인덱스를 만드는 이유

                            - 인덱스를 따로 탈 수 없음.

                            b와 c 인덱스가 따로 걸려있다면

                            - b > 50 && c< 30 두개를 못탐
                            - 좋은거 하나밖에 못탄다.
                            	왜?
                              - 인덱스의 결과를 가지고

                            - 인덱스를 100개 만들어도, 한 개도 안탈 수 있ㅇㅁ
                              - 성능만 안좋아지는 것

                            - 인덱스를 잘타는지 볼려면 explain 이라는 명령어를 통해서 쿼리 플랜을 봐야한다.
                            - mysql이 쿼리가 어떻게 실행되는지 보여준다.
                            ```

                            ![./img_0524/Untitled%2023.png](./img_0524/Untitled%2023.png)
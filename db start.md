## row로우 (데이터베이스)
- https://ko.wikipedia.org/wiki/%EB%A1%9C%EC%9A%B0_(%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4)
위키백과, 우리 모두의 백과사전.
로우(row, 행)는 관계형 데이터베이스에서 레코드(record) 또는 튜플(tuple)로 불리기도 하며, 어떤 테이블에서 단일 구조 데이터 항목을 가리킨다. 간단한 용어로, 데이터베이스 테이블은 로우와 컬럼 또는 필드로 구성되어 있다고 간주할 수 있다. 각 테이블의 행은 일련의 관련 자료를 나타내며, 테이블에서 모든 로우는 동일한 구조를 가지고 있다
개요
예를 들어, 회사를 나타내는 한 테이블 안에서 각 행은 하나의 회사를 나타낸다. 컬럼은 회사명, 회사 주소 등등의 것들을 나타낼 것이다. 부서 정보를 가진 사원의 조합을 나타내는 테이블에는 각 행에 1명의 사원이 1개의 부서와 연관되어 있을 것이다.

공식적으로 덜 이용되는 공식적으로 관계가 있지 않은 데이터베이스에서 레코드는 상기한 바와 같이 레코드와 같지만, 행으로 언급되지는 않는다.

행의 명백한 구조와 행에서의 데이터 값의 의미는 행의 연속적인 데이터 값과 테이블에서의 각 컬럼 중에 하나를 제공해야 하는 것으로 이해가 된다. 그러면 행은 각 튜플이 2개의 항목(적절한 컬럼명과 이 행이 컬럼에 제공하는 값)을 가지는 튜플의 세트로 구성된 관계변수로서 해석이 된다.

각 컬럼은 특정한 타입의 자료형을 가진 데이터 값을 기대한다. 예를 들어, 하나의 컬럼은 유니크한 식별자를 필요로 할 것이고, 다른 것은 그 사람의 이름을 가진 텍스트를, 그리고 시급을 나타내는 센트 단위의 급여(정수)를 필요로 할 것이다.
- 튜플이란?
튜플은 셀 수 있는 수량의 순서 있는 열거이다. n 개의 요소를 가진 튜플을 n-튜플 또는 n중쌍, n짝이라고 한다. 비어 있는 열은 유일한 0-튜플이다. 임의의 n-튜플은 순서쌍의 개념을 이용하여 재귀적으로 정의된다. 튜플은 다른 수학 개념들을 나타내는 데에 자주 사용ehla

### 로우의 특징
SQL에서 레코드는 행(row)라고 불린다.
속성은 속성명과 정의영역(도메인)의 이름 쌍이다.
정의영역(domain)은 데이터 형식과 같은 의미로 사용된다.
속성은 그 정의영역에 적용되는 하위 속성값을 가진다.
한 쌍 있어서는 그 세트에 포함되는 속성 각각 그 속성 정의 영역의 속성 값을 가진다.
속성 값은 스칼라 값 이나 더 복잡한 구조를 가지는 값이다.
수학의 쌍과 달리 관계 모델의 쌍을 구성하는 속성은 정렬되지 않는다.
쌍을 구성하는 속성의 수를 차수(degree)라고 한다.
쌍 차수는 0 또는 양의 정수이다.
차수가 n인 쌍을 n쌍(n -tuple)이라고 한다.
관계값 (또는 단순히 관계)는 0 이상 동일한 형식 쌍의 집합으로 구성된다.

------------

## 컬럼 컬럼 (데이터베이스)
위키백과, 우리 모두의 백과사전.
컬럼(column)이란 관계형 데이터베이스 테이블에서 특정한 단순 자료형의 일련의 데이터값과 테이블에서의 각 열을 말한다. 컬럼은 열이 어떻게 구성되어야 할 지에 대한 구조를 제공한다.

관계형 데이터베이스 용어에서 컬럼과 같은 의미로 사용되는 것은 속성(attribute)이다.

‘필드’(field)라는 용어가 종종 컬럼의 대용으로 동일한 의미로 사용되지만, 필드와 필드값은 한 열이나 한 컬럼 사이의 교차로 존재하는 단일 항목을 특정할 때 언급하

------

## 테이블 (데이터베이스)
위키백과, 우리 모두의 백과사전.
관계형 데이터베이스와 플랫 파일 데이터베이스에서 테이블(table)은 세로줄과 가로줄의 모델을 이용하여 정렬된 데이터 집합(값)의 모임이다.

테이블 내의 데이터는 물리적으로 데이터베이스에 저장되지는 않는다. 뷰 또한 관계형 테이블이지만 이들의 데이터는 쿼리 시간에 계산된다. 다른 예로 별명(nickname)이 있는데 이는 다른 데이터베이스의 표를 가리키는 포인터를 나타낸다.

---------

## 관계형 데이터베이스에서 관계란?

관계 (데이터베이스)
위키백과, 우리 모두의 백과사전.

관계, 투플(tuple), 그리고 속성(attribute)은 테이블, 행(row) 그리고 열(column)로 타나난다.
관계 모델에서 관계(relation)는 동일한 구조로 이루어진 튜플의 집합을 말한다. 값으로서의 관계를 ‘관계값’(relation value)라고 하며, 관계값을 값으로 가지는 변수를 ‘관계변수’(relvar, relation variable)라고 한다.

속성명과 연결된 도메인(열)들을 정의한 것은 ‘관계 스키마’(relation schema)라고 불린다.[1][2] 때로는 관계 스키마는 관계 그 자체의 이름에 포함되기도 한다. 이러한 관계 스키마는 ‘테이블 스키마’(table schema)로도 불리기도 한다.[3][4]

관계 데이터베이스의 데이터베이스 언어인 SQL에서는 관계 변수와 거의 같은 의미로 테이블이라는 용어가 사용되고 있다. 문맥에 따라서 ‘관계변수’를 ‘관계’라고 부르기도 하고 ‘관계값’을 관계라고 부르기도 한다.

기타 데이터베이스의 관계는 다음과 같은 것을 말할 수 있다.

관계변수를 값으로 갖는 관계값은 시간에 따라 변화한다.
관계변수는 데이터 정의 언어(DDL)를 사용하여 정의할 수 있다.
제목(heading)은 특정 속성(열) 이 정렬되지 않은 집합이다.
관계값을 구성하는 튜플의 집합을 본체 (body)라고 한다. 즉 관계 값은 제목과 본체로 구성되어있다.
튜플은 0개 이상의 속성의 집합으로 구성된 데이터 구조이다.
속성(attribute)은 속성명과 정의영역 이름 열이다.
정의영역(domain)은 데이터 형식과 같은 의미로 생각해도 좋다.[5]
속성은 그 정의영역에 적용되는 하위의 속성 값을 가진다.
속성 값은 스칼라 값이나 더 복잡한 구조를 가지는 값이다.
제목을 구성하는 속성의 수를 차수(degree)라고 한다.
관계값의 차수는 0 또는 양의 정수이다.
차수가 n인 관계 값을 n항 관계(n-ary relation)라고 한다.
관계값을 구성하는 튜플 수를 농도 (cardinality)라고 한다.
관계값의 농도는 0 또는 양의 정수이다.
관계값은 중복 튜플이 존재하지 않는다.
관계 값을 구성하는 각각의 열은 특정한 하나 이상의 속성 집합으로 식별된다. 이 속성 집합을 후보 키(candidate key)라고 한다.




---------

## VIEW (SQL)
위키백과, 우리 모두의 백과사전.
(뷰 (데이터베이스)에서 넘어옴)
뷰(view)는 관계 데이터베이스의 데이터베이스 언어 SQL에서 하나 이상의 테이블 (또는 다른 뷰)에서 원하는 모든 데이터를 선택하여, 그들을 사용자 정의하여 나타낸 것이다. 관계 데이터베이스의 관계 모델의 관계의 일종인 도출 관계에 해당한다. 여러 테이블(기본 관계) 또는 뷰의 데이터를 연결하여 조합할 수 있다. 보기에 표시되는 데이터의 선택 기준을 지정할 수도 있다.

뷰는 기본 테이블(table)과 같이 행(column)과 열(row)로 구성되지만, 다른 테이블에 있는 데이터를 보여줄 뿐이며, 실제 테이블과 달리 데이터 자체를 포함하고 있는 것은 아니다. 뷰를 사용하면 여러 테이블이나 뷰를 하나의 테이블인 것처럼 볼 수 있다

정의된 정렬 순서가 모자란 기본적인 테이블의 열처럼, 뷰를 통해 생성된 열도 특정 순서로 정렬되어 나타나지 않는다. 뷰는 관계 테이블이며, 관계 모델은 테이블을 일련의 열로 정의를 한다. 그러한 세트는 (정의를 내림으로써) 정렬되지 않기 때문에, 뷰의 테이블도 마찬가지다. 따라서 ORDER BY 구문은 뷰의 정의에서 무의미하며, 표준 SQL2003에서는 ORDER BY 구문을 CREATE VIEW 명령의 옵션에서 허용하지 않았으며, 마찬가지로 CREATE TABLE 구문에서 거분된 것이다. 그러나 정렬된 데이터는 다른 테이블로서 동일한 방법으로 뷰를 통해 획득할 수 있다. 그럼에도 불구하고 오라클 데이터베이스와 같은 일부 DBMS에서는 이러한 SQL 표준 제한을 따르지 않고, 허용하고 있다.

### VIEW 사용법
구문
생성
뷰 생성 시에 다음과 같이 SQL 문을 작성한다. 기존에 있던 테이블에 있는 컬럼에서 원하는 자료만 조회하는 것이기 때문에, 만들 때도 SELECT 문을 통해 생성한다.

CREATE VIEW 뷰이름 AS SELECT 구문;
삭제
뷰 자체를 삭제하는 것은 다음과 같이 DROP SQL 문을 작성한다.

DROP VIEW 뷰이름;
뷰를 만드는 사람은 뷰를 읽기전용(read-only)과 업데이트 가능(updatable) 상태로 정의할 수 있다. 만약 데이터베이스가 뷰의 스키마에서 내장된 기본 테이블의 스키마로 역 매핑을 결정할 수 있다면, 뷰는 업데이트 가능하다. INSERT, UPDATE, DELETE 동작은 업데이트 가능 뷰에서 실행될 수 있다. 원 테이블에 변경을 매핑하지 않기 때문에 읽기전용에서는 그러한 동작을 지원하지 않는다. 뷰 업데이트는 키 보존에 의해 실행된다.

일부 시스템은 뷰에서 INSTEAD OF 트리거를 지원한다. 이런 기술은 뷰에서 실행되는 Insert, update, delete의 위치에서 실행되는 다른 로직 정의를 가능하게 한다. 그리하여 데이터베이스 시스템은 뷰의 읽기전용에 기반한 데이터 수정 작업을 실행할 수 있다. 그러나 INSTEAD OF 트리거는 뷰 자체의 읽기전용이나 업데이트가능 속성을 변경하지는 못한다.

상응
뷰는 원 소스의 쿼리와 동일하다. 뷰와 같은 쿼리가 실행되면, 쿼리는 수정되어 버린다. 예를 들어, 다음과 같은 accounts_view라는 이름의 쿼리가 있다고 하자:


accounts_view:
SELECT name,
       money_received,
       money_sent,
       (money_received - money_sent) AS balance,
       address,
 ...
  FROM table_customers c
  JOIN accounts_table a
    ON a.customer_id = c.customer_id
그러면, 애플리케이션에서 다음과 같은 간단한 쿼리를 실행할 수 있다고 가정하자:

간단한 쿼리
SELECT name,
       balance
  FROM accounts_view
그러면 RDBMS는 간단한 쿼리를 취해서, 동일한 뷰를 치환해 버리며, 아래의 것을 쿼리 최적화도구로 전송한다:

선 실행 쿼리:
SELECT name,
       balance
  FROM (SELECT name,
               money_received,
               money_sent,
               (money_received - money_sent) AS balance,
               address,
 ...
          FROM table_customers c JOIN accounts_table a
               ON a.customer_id = c.customer_id        )
이 시점에서의 최적화도구는 쿼리를 취해서 필요없는 복잡함을 제거하며(예: 주소를 읽는 것은 필요치 않다, 부모 자원이 그것을 이용하지 않기 때문에), 프로세싱을 위해 SQL 엔진에 그 쿼리를 전송한다.
